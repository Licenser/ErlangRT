#!/usr/bin/env python3
# takes: genop.tab from erlang/otp
# Prints a Rust source file of VM dispatch, huge match statement with all
# opcodes
import erlangrt.genop as genop


def main():
    conf = genop.OTP20()
    tables = genop.OTPTables(conf)

    print("""\
//! Generated by `codegen/create_vm_dispatch.py`
//! Dispatch for all opcode types.
//! Config used: {otp}
#![allow(dead_code)]

use emulator::vm::VM;
use beam::gen_op;
use beam::opcodes::*;
use beam::disp_result::{{DispatchResult}};
use emulator::code::opcode::RawOpcode;
use emulator::process::Process;
use emulator::runtime_ctx::Context;


#[inline]
pub fn dispatch_op_inline(vm: &VM, op: RawOpcode, ctx: &mut Context, \
curr_p: &mut Process) -> DispatchResult {{
  match op {{""".format(op_max=conf.max_opcode, otp=conf.__class__.__name__))

    for opcode in range(conf.min_opcode, conf.max_opcode + 1):
        op = tables.ops[opcode]
        if op.name in tables.implemented_ops:
            print("    gen_op::OPCODE_{opcode} => "
                  "return opcode_{lowercase}(vm, ctx, curr_p),"
                  "".format(opcode=op.name.upper(), lowercase=op.name))

    print("""\
    other => unknown_opcode(other, ctx),
  }
  DispatchResult::Yield
}
""")


if __name__ == "__main__":
    main()
